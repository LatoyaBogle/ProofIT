{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path = require(\"path\");\n\nvar globParent = require(\"glob-parent\");\n\nvar isGlob = require(\"is-glob\");\n\nvar micromatch = require(\"micromatch\");\n\nvar GLOBSTAR = '**';\n/**\n * Return true for static pattern.\n */\n\nfunction isStaticPattern(pattern) {\n  return !isDynamicPattern(pattern);\n}\n\nexports.isStaticPattern = isStaticPattern;\n/**\n * Return true for pattern that looks like glob.\n */\n\nfunction isDynamicPattern(pattern) {\n  return isGlob(pattern);\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n/**\n * Convert a windows «path» to a unix-style «path».\n */\n\nfunction unixifyPattern(pattern) {\n  return pattern.replace(/\\\\/g, '/');\n}\n\nexports.unixifyPattern = unixifyPattern;\n/**\n * Returns negative pattern as positive pattern.\n */\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n/**\n * Returns positive pattern as negative pattern.\n */\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n/**\n * Return true if provided pattern is negative pattern.\n */\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n/**\n * Return true if provided pattern is positive pattern.\n */\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n/**\n * Extracts negative patterns from array of patterns.\n */\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n/**\n * Extracts positive patterns from array of patterns.\n */\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Extract base directory from provided pattern.\n */\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern);\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n/**\n * Return true if provided pattern has globstar.\n */\n\nfunction hasGlobStar(pattern) {\n  return pattern.indexOf(GLOBSTAR) !== -1;\n}\n\nexports.hasGlobStar = hasGlobStar;\n/**\n * Return true if provided pattern ends with slash and globstar.\n */\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n/**\n * Returns «true» when pattern ends with a slash and globstar or the last partial of the pattern is static pattern.\n */\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  var basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n/**\n * Return naive depth of provided pattern without depth of the base directory.\n */\n\nfunction getNaiveDepth(pattern) {\n  var base = getBaseDirectory(pattern);\n  var patternDepth = pattern.split('/').length;\n  var patternBaseDepth = base.split('/').length;\n  /**\n   * This is a hack for pattern that has no base directory.\n   *\n   * This is related to the `*\\something\\*` pattern.\n   */\n\n  if (base === '.') {\n    return patternDepth - patternBaseDepth;\n  }\n\n  return patternDepth - patternBaseDepth - 1;\n}\n\nexports.getNaiveDepth = getNaiveDepth;\n/**\n * Return max naive depth of provided patterns without depth of the base directory.\n */\n\nfunction getMaxNaivePatternsDepth(patterns) {\n  return patterns.reduce(function (max, pattern) {\n    var depth = getNaiveDepth(pattern);\n    return depth > max ? depth : max;\n  }, 0);\n}\n\nexports.getMaxNaivePatternsDepth = getMaxNaivePatternsDepth;\n/**\n * Make RegExp for provided pattern.\n */\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n/**\n * Convert patterns to regexps.\n */\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(function (pattern) {\n    return makeRe(pattern, options);\n  });\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n/**\n * Returns true if the entry match any of the given RegExp's.\n */\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(function (patternRe) {\n    return patternRe.test(entry);\n  });\n}\n\nexports.matchAny = matchAny;","map":null,"metadata":{},"sourceType":"script"}