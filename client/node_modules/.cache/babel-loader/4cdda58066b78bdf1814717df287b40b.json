{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\Concordiae\\\\Desktop\\\\ProofIT\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar each = require('lodash.foreach');\n\nvar get = require('lodash.get'); // Function typecheck helper\n\n\nvar isFunc = function isFunc(val) {\n  return typeof val === 'function';\n};\n\nvar deepPath = function deepPath(schema, pathName) {\n  var path;\n  var paths = pathName.split('.');\n\n  if (paths.length > 1) {\n    pathName = paths.shift();\n  }\n\n  if (isFunc(schema.path)) {\n    path = schema.path(pathName);\n  }\n\n  if (path && path.schema) {\n    path = deepPath(path.schema, paths.join('.'));\n  }\n\n  return path;\n}; // Export the mongoose plugin\n\n\nmodule.exports = function (schema, options) {\n  options = options || {};\n  var type = options.type || 'unique';\n  var message = options.message || 'Error, expected `{PATH}` to be unique. Value: `{VALUE}`'; // Mongoose Schema objects don't describe default _id indexes\n  // https://github.com/Automattic/mongoose/issues/5998\n\n  var indexes = [[{\n    _id: 1\n  }, {\n    unique: true\n  }]].concat(schema.indexes()); // Dynamically iterate all indexes\n\n  each(indexes, function (index) {\n    var indexOptions = index[1];\n\n    if (indexOptions.unique) {\n      var paths = Object.keys(index[0]);\n      each(paths, function (pathName) {\n        // Choose error message\n        var pathMessage = typeof indexOptions.unique === 'string' ? indexOptions.unique : message; // Obtain the correct path object\n\n        var path = deepPath(schema, pathName) || schema.path(pathName);\n\n        if (path) {\n          // Add an async validator\n          path.validate(function () {\n            var _this = this;\n\n            return new Promise(function (resolve) {\n              var isSubdocument = isFunc(_this.ownerDocument);\n              var isQuery = _this.constructor.name === 'Query';\n              var parentDoc = isSubdocument ? _this.ownerDocument() : _this;\n              var isNew = typeof parentDoc.isNew === 'boolean' ? parentDoc.isNew : !isQuery;\n              var conditions = [];\n              each(paths, function (name) {\n                var pathValue; // If the doc is a query, this is a findAndUpdate\n\n                if (isQuery) {\n                  pathValue = get(_this, '_update.' + name) || get(_this, '_update.$set.' + name);\n                } else {\n                  pathValue = get(_this, isSubdocument ? name.split('.').pop() : name);\n                } // Wrap with case-insensitivity\n\n\n                if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\n                  pathValue = new RegExp('^' + pathValue + '$', 'i');\n                }\n\n                conditions.push(_defineProperty({}, name, pathValue));\n              });\n\n              if (!isNew) {\n                // Use conditions the user has with find*AndUpdate\n                if (isQuery) {\n                  each(_this._conditions, function (value, key) {\n                    conditions.push(_defineProperty({}, key, {\n                      $ne: value\n                    }));\n                  });\n                } else if (_this._id) {\n                  conditions.push({\n                    _id: {\n                      $ne: _this._id\n                    }\n                  });\n                }\n              } // Obtain the model depending on context\n              // https://github.com/Automattic/mongoose/issues/3430\n              // https://github.com/Automattic/mongoose/issues/3589\n\n\n              var model;\n\n              if (isQuery) {\n                model = _this.model;\n              } else if (isSubdocument) {\n                model = _this.ownerDocument().model(_this.ownerDocument().constructor.modelName);\n              } else if (isFunc(_this.model)) {\n                model = _this.model(_this.constructor.modelName);\n              }\n\n              model.where({\n                $and: conditions\n              }).countDocuments(function (err, count) {\n                resolve(count === 0);\n              });\n            });\n          }, pathMessage, type);\n        }\n      });\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}