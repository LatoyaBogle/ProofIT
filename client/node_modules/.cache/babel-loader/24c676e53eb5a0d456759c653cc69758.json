{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar patternUtils = require(\"../utils/pattern\");\n/**\n * Generate tasks based on parent directory of each pattern.\n */\n\n\nfunction generate(patterns, options) {\n  var unixPatterns = patterns.map(patternUtils.unixifyPattern);\n  var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);\n  var positivePatterns = getPositivePatterns(unixPatterns);\n  var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);\n  var staticPatterns = positivePatterns.filter(patternUtils.isStaticPattern);\n  var dynamicPatterns = positivePatterns.filter(patternUtils.isDynamicPattern);\n  var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns,\n  /* dynamic */\n  false);\n  var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns,\n  /* dynamic */\n  true);\n  return staticTasks.concat(dynamicTasks);\n}\n\nexports.generate = generate;\n/**\n * Convert patterns to tasks based on parent directory of each pattern.\n */\n\nfunction convertPatternsToTasks(positive, negative, dynamic) {\n  var positivePatternsGroup = groupPatternsByBaseDirectory(positive); // When we have a global group â€“ there is no reason to divide the patterns into independent tasks.\n  // In this case, the global task covers the rest.\n\n  if ('.' in positivePatternsGroup) {\n    var task = convertPatternGroupToTask('.', positive, negative, dynamic);\n    return [task];\n  }\n\n  return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);\n}\n\nexports.convertPatternsToTasks = convertPatternsToTasks;\n/**\n * Return only positive patterns.\n */\n\nfunction getPositivePatterns(patterns) {\n  return patternUtils.getPositivePatterns(patterns);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Return only negative patterns.\n */\n\nfunction getNegativePatternsAsPositive(patterns, ignore) {\n  var negative = patternUtils.getNegativePatterns(patterns).concat(ignore);\n  var positive = negative.map(patternUtils.convertToPositivePattern);\n  return positive;\n}\n\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\n/**\n * Group patterns by base directory of each pattern.\n */\n\nfunction groupPatternsByBaseDirectory(patterns) {\n  return patterns.reduce(function (collection, pattern) {\n    var base = patternUtils.getBaseDirectory(pattern);\n\n    if (base in collection) {\n      collection[base].push(pattern);\n    } else {\n      collection[base] = [pattern];\n    }\n\n    return collection;\n  }, {});\n}\n\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\n/**\n * Convert group of patterns to tasks.\n */\n\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\n  return Object.keys(positive).map(function (base) {\n    return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n  });\n}\n\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\n/**\n * Create a task for positive and negative patterns.\n */\n\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\n  return {\n    base: base,\n    dynamic: dynamic,\n    patterns: [].concat(positive, negative.map(patternUtils.convertToNegativePattern)),\n    positive: positive,\n    negative: negative\n  };\n}\n\nexports.convertPatternGroupToTask = convertPatternGroupToTask;","map":null,"metadata":{},"sourceType":"script"}